{
  "version": 3,
  "sources": ["../src/utils/dom.ts", "../src/ui/elements.ts", "../src/canvas/draw.ts", "../src/input/drag.ts", "../src/utils/clamp.ts", "../src/input/zoom.ts", "../src/utils/image.ts", "../src/utils/points.ts", "../src/Croppie.ts"],
  "sourcesContent": [
    "/**\n * Create an HTML element of the given tag and apply optional class, attributes, and styles.\n *\n * @param tag - The tag name of the element to create.\n * @param options - Optional configuration for the created element.\n * @param options.className - A string to assign to the element's `className`.\n * @param options.attributes - Key/value pairs to set as attributes on the element.\n * @param options.styles - Partial style declarations to merge into the element's `style`.\n * @returns The newly created and configured element.\n */\nexport function createElement<K extends keyof HTMLElementTagNameMap>(\n\ttag: K,\n\toptions?: {\n\t\tclassName?: string;\n\t\tattributes?: Record<string, string>;\n\t\tstyles?: Partial<CSSStyleDeclaration>;\n\t},\n): HTMLElementTagNameMap[K] {\n\tconst element = document.createElement(tag);\n\n\tif (options?.className) {\n\t\telement.className = options.className;\n\t}\n\n\tif (options?.attributes) {\n\t\tfor (const [key, value] of Object.entries(options.attributes)) {\n\t\t\telement.setAttribute(key, value);\n\t\t}\n\t}\n\n\tif (options?.styles) {\n\t\tObject.assign(element.style, options.styles);\n\t}\n\n\treturn element;\n}\n\n/**\n * Extracts the translation (x, y) and uniform scale from an element's computed CSS transform.\n *\n * @param element - The element whose computed transform will be inspected.\n * @returns An object with `x` and `y` translation values (in CSS pixels) and `scale` as the uniform scaling factor; defaults to `x: 0`, `y: 0`, `scale: 1` when no transform is present or cannot be parsed.\n */\nexport function getTransformValues(element: HTMLElement): {\n\tx: number;\n\ty: number;\n\tscale: number;\n} {\n\tconst style = window.getComputedStyle(element);\n\tconst transform = style.transform;\n\n\tif (!transform || transform === \"none\") {\n\t\treturn { x: 0, y: 0, scale: 1 };\n\t}\n\n\t// matrix(a, b, c, d, tx, ty) or matrix3d(...)\n\tconst match = transform.match(/matrix.*\\((.+)\\)/);\n\tif (!match?.[1]) {\n\t\treturn { x: 0, y: 0, scale: 1 };\n\t}\n\n\tconst values = match[1].split(\", \").map(Number);\n\n\tif (values.length === 6) {\n\t\t// 2D matrix\n\t\treturn {\n\t\t\tx: values[4] ?? 0,\n\t\t\ty: values[5] ?? 0,\n\t\t\tscale: Math.sqrt((values[0] ?? 1) ** 2 + (values[1] ?? 0) ** 2),\n\t\t};\n\t}\n\n\t// 3D matrix (16 values)\n\treturn {\n\t\tx: values[12] ?? 0,\n\t\ty: values[13] ?? 0,\n\t\tscale: values[0] ?? 1,\n\t};\n}\n\n/**\n * Set an element's CSS transform to a translation (in pixels) and a uniform scale.\n *\n * @param element - The target HTMLElement to transform\n * @param x - Horizontal translation in pixels\n * @param y - Vertical translation in pixels\n * @param scale - Uniform scale factor (1 = no scale)\n */\nexport function setTransform(\n\telement: HTMLElement,\n\tx: number,\n\ty: number,\n\tscale: number,\n): void {\n\telement.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;\n}\n",
    "import type { Boundary, Viewport, ViewportType } from \"../types.ts\";\nimport { createElement } from \"../utils/dom.ts\";\n\n/**\n * Create the croppie container element.\n *\n * @param customClass - Optional additional class name to append to the container's class list\n * @returns The created div element with class \"croppie-container\" and the optional `customClass` appended\n */\nexport function createContainer(customClass?: string): HTMLDivElement {\n\tconst container = createElement(\"div\", {\n\t\tclassName: `croppie-container${customClass ? ` ${customClass}` : \"\"}`,\n\t});\n\treturn container;\n}\n\n/**\n * Create the outer boundary element that constrains the crop area.\n *\n * @param boundary - Object describing the boundary's width and height in pixels\n * @returns The created div element used as the boundary container\n */\nexport function createBoundary(boundary: Boundary): HTMLDivElement {\n\tconst element = createElement(\"div\", {\n\t\tclassName: \"cr-boundary\",\n\t\tstyles: {\n\t\t\twidth: `${boundary.width}px`,\n\t\t\theight: `${boundary.height}px`,\n\t\t\tposition: \"relative\",\n\t\t\toverflow: \"hidden\",\n\t\t},\n\t});\n\treturn element;\n}\n\n/**\n * Create a positioned, sized DOM element that represents the crop viewport.\n *\n * @param viewport - Object describing the viewport's width, height, and type which determine the element's size and shape\n * @returns The configured `HTMLDivElement` to be used as the viewport element (includes class `cr-viewport cr-vp-{type}`)\n */\nexport function createViewport(viewport: Viewport): HTMLDivElement {\n\tconst element = createElement(\"div\", {\n\t\tclassName: `cr-viewport cr-vp-${viewport.type}`,\n\t\tstyles: {\n\t\t\twidth: `${viewport.width}px`,\n\t\t\theight: `${viewport.height}px`,\n\t\t\tposition: \"absolute\",\n\t\t\ttop: \"50%\",\n\t\t\tleft: \"50%\",\n\t\t\ttransform: \"translate(-50%, -50%)\",\n\t\t\tpointerEvents: \"none\",\n\t\t\tborderRadius: viewport.type === \"circle\" ? \"50%\" : \"0\",\n\t\t},\n\t});\n\treturn element;\n}\n\n/**\n * Creates the overlay that darkens the area outside the viewport.\n *\n * @param boundary - The cropping boundary used to position and size the overlay mask\n * @param viewport - The viewport dimensions and type that define the transparent cutout\n * @returns The overlay div element with a semi-transparent black background and a mask that cuts out the viewport area\n */\nexport function createOverlay(\n\tboundary: Boundary,\n\tviewport: Viewport,\n): HTMLDivElement {\n\tconst element = createElement(\"div\", {\n\t\tclassName: \"cr-overlay\",\n\t\tstyles: {\n\t\t\tposition: \"absolute\",\n\t\t\ttop: \"0\",\n\t\t\tleft: \"0\",\n\t\t\twidth: \"100%\",\n\t\t\theight: \"100%\",\n\t\t\tpointerEvents: \"none\",\n\t\t},\n\t});\n\n\t// The overlay uses a CSS mask or clip-path to create the cutout\n\tconst maskImage = createMaskImage(boundary, viewport);\n\telement.style.background = \"rgba(0, 0, 0, 0.5)\";\n\telement.style.maskImage = maskImage;\n\telement.style.webkitMaskImage = maskImage;\n\n\treturn element;\n}\n\n/**\n * Generates a CSS `mask-image` string that creates a transparent cutout for the viewport centered in the boundary.\n *\n * @param boundary - Dimensions of the bounding container used to center the cutout.\n * @param viewport - Viewport dimensions and type (\"circle\" for circular cutouts, otherwise rectangular).\n * @returns A CSS `mask-image` value: a `radial-gradient` for circular viewports or two overlapping `linear-gradient`s for rectangular viewports that together produce a transparent hole where the viewport is located.\n */\nfunction createMaskImage(boundary: Boundary, viewport: Viewport): string {\n\tconst centerX = boundary.width / 2;\n\tconst centerY = boundary.height / 2;\n\n\tif (viewport.type === \"circle\") {\n\t\tconst radius = viewport.width / 2;\n\t\t// Create a radial gradient that's transparent in the center\n\t\treturn `radial-gradient(circle ${radius}px at ${centerX}px ${centerY}px, transparent ${radius}px, black ${radius}px)`;\n\t}\n\n\t// For square, use a more complex gradient\n\tconst left = centerX - viewport.width / 2;\n\tconst right = centerX + viewport.width / 2;\n\tconst top = centerY - viewport.height / 2;\n\tconst bottom = centerY + viewport.height / 2;\n\n\t// This creates a rectangular hole using CSS gradients\n\treturn `\n    linear-gradient(to right, black ${left}px, transparent ${left}px, transparent ${right}px, black ${right}px),\n    linear-gradient(to bottom, black ${top}px, transparent ${top}px, transparent ${bottom}px, black ${bottom}px)\n  `;\n}\n\n/**\n * Create the image element used as the crop preview.\n *\n * The element is configured with alt text, non-draggable behavior, absolute positioning,\n * origin at the top-left, and no maximum width/height so it can be transformed freely.\n *\n * @returns The configured HTMLImageElement used to display the source image inside the cropper.\n */\nexport function createPreview(): HTMLImageElement {\n\tconst element = createElement(\"img\", {\n\t\tclassName: \"cr-image\",\n\t\tattributes: {\n\t\t\talt: \"Cropper image\",\n\t\t\tdraggable: \"false\",\n\t\t},\n\t\tstyles: {\n\t\t\tposition: \"absolute\",\n\t\t\ttop: \"0\",\n\t\t\tleft: \"0\",\n\t\t\ttransformOrigin: \"0 0\",\n\t\t\tmaxWidth: \"none\",\n\t\t\tmaxHeight: \"none\",\n\t\t},\n\t});\n\treturn element;\n}\n\n/**\n * Creates a range input element configured as the zoom slider.\n *\n * @param min - Minimum slider value\n * @param max - Maximum slider value\n * @param value - Initial slider value\n * @returns The configured HTMLInputElement with type `\"range\"` and `step` set to `0.01`\n */\nexport function createZoomSlider(\n\tmin: number,\n\tmax: number,\n\tvalue: number,\n): HTMLInputElement {\n\tconst element = createElement(\"input\", {\n\t\tclassName: \"cr-slider\",\n\t\tattributes: {\n\t\t\ttype: \"range\",\n\t\t\tmin: String(min),\n\t\t\tmax: String(max),\n\t\t\tstep: \"0.01\",\n\t\t\tvalue: String(value),\n\t\t},\n\t});\n\treturn element;\n}\n\n/**\n * Create the slider container element used to wrap the zoom slider.\n *\n * @returns The created div element with class \"cr-slider-wrap\".\n */\nexport function createSliderContainer(): HTMLDivElement {\n\treturn createElement(\"div\", {\n\t\tclassName: \"cr-slider-wrap\",\n\t});\n}\n",
    "import type { CropPoints, OutputFormat } from \"../types.ts\";\n\n/**\n * Create a new canvas containing the specified rectangular region of an image, scaled to given dimensions and optionally masked or filled.\n *\n * @param image - Source HTMLImageElement to draw from.\n * @param points - Crop rectangle in source-image pixels; must provide `topLeftX`, `topLeftY`, `bottomRightX`, and `bottomRightY`.\n * @param outputWidth - Width of the resulting canvas in pixels.\n * @param outputHeight - Height of the resulting canvas in pixels.\n * @param options - Optional rendering options.\n * @param options.circle - If true, apply a circular clipping mask centered in the output canvas.\n * @param options.backgroundColor - If provided, fill the canvas background with this CSS color before drawing the image.\n * @returns An HTMLCanvasElement containing the cropped (and optionally masked) image scaled to `outputWidth` x `outputHeight`.\n * @throws If the 2D rendering context cannot be obtained from the created canvas.\n */\nexport function drawCroppedImage(\n\timage: HTMLImageElement,\n\tpoints: CropPoints,\n\toutputWidth: number,\n\toutputHeight: number,\n\toptions?: {\n\t\tcircle?: boolean;\n\t\tbackgroundColor?: string;\n\t},\n): HTMLCanvasElement {\n\tconst canvas = document.createElement(\"canvas\");\n\tcanvas.width = outputWidth;\n\tcanvas.height = outputHeight;\n\n\tconst ctx = canvas.getContext(\"2d\");\n\tif (!ctx) {\n\t\tthrow new Error(\"Failed to get 2D context\");\n\t}\n\n\t// Fill background if specified\n\tif (options?.backgroundColor) {\n\t\tctx.fillStyle = options.backgroundColor;\n\t\tctx.fillRect(0, 0, outputWidth, outputHeight);\n\t}\n\n\t// Apply circular mask if needed\n\tif (options?.circle) {\n\t\tctx.beginPath();\n\t\tctx.arc(outputWidth / 2, outputHeight / 2, outputWidth / 2, 0, Math.PI * 2);\n\t\tctx.closePath();\n\t\tctx.clip();\n\t}\n\n\t// Calculate source dimensions from points\n\tconst sourceWidth = points.bottomRightX - points.topLeftX;\n\tconst sourceHeight = points.bottomRightY - points.topLeftY;\n\n\t// Draw the cropped region\n\tctx.drawImage(\n\t\timage,\n\t\tpoints.topLeftX,\n\t\tpoints.topLeftY,\n\t\tsourceWidth,\n\t\tsourceHeight,\n\t\t0,\n\t\t0,\n\t\toutputWidth,\n\t\toutputHeight,\n\t);\n\n\treturn canvas;\n}\n\n/**\n * Creates a Blob containing the canvas image encoded in the specified format.\n *\n * @param canvas - The source canvas to encode\n * @param format - Output image format (e.g., `\"png\"`, `\"jpeg\"`); defaults to `\"png\"`\n * @param quality - Quality value between 0 and 1 used by encoders that support it; defaults to `0.92`\n * @returns A Blob containing the encoded image with MIME type `image/{format}`\n */\nexport function canvasToBlob(\n\tcanvas: HTMLCanvasElement,\n\tformat: OutputFormat = \"png\",\n\tquality = 0.92,\n): Promise<Blob> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst mimeType = `image/${format}`;\n\n\t\tcanvas.toBlob(\n\t\t\t(blob) => {\n\t\t\t\tif (blob) {\n\t\t\t\t\tresolve(blob);\n\t\t\t\t} else {\n\t\t\t\t\treject(new Error(\"Failed to create blob from canvas\"));\n\t\t\t\t}\n\t\t\t},\n\t\t\tmimeType,\n\t\t\tquality,\n\t\t);\n\t});\n}\n\n/**\n * Create a base64-encoded data URL representing the canvas image.\n *\n * @param canvas - The HTMLCanvasElement to encode as a data URL.\n * @param format - Image format to encode (`\"png\"`, `\"jpeg\"`, etc.). Used to build the MIME type `image/{format}`.\n * @param quality - Image quality between 0 and 1 for formats that use it (e.g., `\"jpeg\"`). Ignored by formats that do not accept a quality parameter.\n * @returns A data URL (base64) containing the encoded image in the specified format.\n */\nexport function canvasToBase64(\n\tcanvas: HTMLCanvasElement,\n\tformat: OutputFormat = \"png\",\n\tquality = 0.92,\n): string {\n\tconst mimeType = `image/${format}`;\n\treturn canvas.toDataURL(mimeType, quality);\n}\n",
    "import type { TransformState } from \"../types.ts\";\n\nexport interface DragCallbacks {\n\tonStart?: (state: TransformState) => void;\n\tonMove?: (state: TransformState) => void;\n\tonEnd?: (state: TransformState) => void;\n}\n\ninterface DragState {\n\tisDragging: boolean;\n\tstartX: number;\n\tstartY: number;\n\tstartTransformX: number;\n\tstartTransformY: number;\n}\n\n/**\n * Attach pointer-based dragging behavior to an element.\n *\n * Sets up handlers that read the current transform via `getTransform`, update it via `setTransform`\n * while the primary pointer is dragged, and invoke the optional lifecycle callbacks.\n *\n * @param element - The HTMLElement to enable dragging on\n * @param getTransform - Function that returns the element's current TransformState\n * @param setTransform - Function to update the element's transform coordinates (`x`, `y`)\n * @param callbacks - Optional callbacks invoked on drag start, move, and end\n * @returns A cleanup function that removes the installed event listeners\n */\nexport function createDragHandler(\n\telement: HTMLElement,\n\tgetTransform: () => TransformState,\n\tsetTransform: (x: number, y: number) => void,\n\tcallbacks?: DragCallbacks,\n): () => void {\n\tconst state: DragState = {\n\t\tisDragging: false,\n\t\tstartX: 0,\n\t\tstartY: 0,\n\t\tstartTransformX: 0,\n\t\tstartTransformY: 0,\n\t};\n\n\tconst handlePointerDown = (e: PointerEvent) => {\n\t\tif (e.button !== 0) return; // Only left click\n\n\t\tstate.isDragging = true;\n\t\tstate.startX = e.clientX;\n\t\tstate.startY = e.clientY;\n\n\t\tconst transform = getTransform();\n\t\tstate.startTransformX = transform.x;\n\t\tstate.startTransformY = transform.y;\n\n\t\telement.setPointerCapture(e.pointerId);\n\t\telement.style.cursor = \"grabbing\";\n\n\t\tcallbacks?.onStart?.(transform);\n\t};\n\n\tconst handlePointerMove = (e: PointerEvent) => {\n\t\tif (!state.isDragging) return;\n\n\t\tconst deltaX = e.clientX - state.startX;\n\t\tconst deltaY = e.clientY - state.startY;\n\n\t\tconst newX = state.startTransformX + deltaX;\n\t\tconst newY = state.startTransformY + deltaY;\n\n\t\tsetTransform(newX, newY);\n\n\t\tconst transform = getTransform();\n\t\tcallbacks?.onMove?.(transform);\n\t};\n\n\tconst handlePointerUp = (e: PointerEvent) => {\n\t\tif (!state.isDragging) return;\n\n\t\tstate.isDragging = false;\n\t\telement.releasePointerCapture(e.pointerId);\n\t\telement.style.cursor = \"grab\";\n\n\t\tconst transform = getTransform();\n\t\tcallbacks?.onEnd?.(transform);\n\t};\n\n\t// Attach listeners\n\telement.addEventListener(\"pointerdown\", handlePointerDown);\n\telement.addEventListener(\"pointermove\", handlePointerMove);\n\telement.addEventListener(\"pointerup\", handlePointerUp);\n\telement.addEventListener(\"pointercancel\", handlePointerUp);\n\n\telement.style.cursor = \"grab\";\n\telement.style.touchAction = \"none\"; // Prevent browser handling\n\n\t// Return cleanup function\n\treturn () => {\n\t\telement.removeEventListener(\"pointerdown\", handlePointerDown);\n\t\telement.removeEventListener(\"pointermove\", handlePointerMove);\n\t\telement.removeEventListener(\"pointerup\", handlePointerUp);\n\t\telement.removeEventListener(\"pointercancel\", handlePointerUp);\n\t};\n}\n",
    "/**\n * Clamp a number to the inclusive range [min, max].\n *\n * @returns The input `value` constrained to be at least `min` and at most `max`.\n */\nexport function clamp(value: number, min: number, max: number): number {\n\treturn Math.min(Math.max(value, min), max);\n}\n",
    "import type { ZoomConfig } from \"../types.ts\";\nimport { clamp } from \"../utils/clamp.ts\";\n\nexport interface ZoomCallbacks {\n\tonChange?: (zoom: number, previousZoom: number) => void;\n}\n\n/**\n * Create and attach a wheel-based zoom handler to an element.\n *\n * When the user scrolls the wheel over the element this handler adjusts the zoom\n * by steps of 0.1, clamped to the supplied `config` bounds, and invokes the\n * optional `onChange` callback when the zoom changes.\n *\n * @param element - The HTMLElement to attach the wheel listener to\n * @param getZoom - Function that returns the current zoom level\n * @param setZoom - Function that updates the zoom level\n * @param config - Zoom bounds; `min` and `max` define the allowed zoom range\n * @param callbacks - Optional callbacks; `onChange(newZoom, previousZoom)` is called when zoom changes\n * @param requireCtrl - If true, the handler only responds when the Ctrl key is pressed (default: `false`)\n * @returns A cleanup function that removes the attached wheel listener\n */\nexport function createWheelZoomHandler(\n\telement: HTMLElement,\n\tgetZoom: () => number,\n\tsetZoom: (zoom: number) => void,\n\tconfig: ZoomConfig,\n\tcallbacks?: ZoomCallbacks,\n\trequireCtrl = false,\n): () => void {\n\tconst handleWheel = (e: WheelEvent) => {\n\t\t// Check for ctrl requirement\n\t\tif (requireCtrl && !e.ctrlKey) return;\n\n\t\t// Ignore zero-movement events (no scroll)\n\t\tif (e.deltaY === 0) return;\n\n\t\te.preventDefault();\n\n\t\tconst previousZoom = getZoom();\n\t\tconst delta = e.deltaY > 0 ? -0.1 : 0.1;\n\t\tconst newZoom = clamp(previousZoom + delta, config.min, config.max);\n\n\t\tif (newZoom !== previousZoom) {\n\t\t\tsetZoom(newZoom);\n\t\t\tcallbacks?.onChange?.(newZoom, previousZoom);\n\t\t}\n\t};\n\n\telement.addEventListener(\"wheel\", handleWheel, { passive: false });\n\n\treturn () => {\n\t\telement.removeEventListener(\"wheel\", handleWheel);\n\t};\n}\n\n/**\n * Attaches pinch-to-zoom touch handlers to an element and returns a cleanup function.\n *\n * Handles two-finger pinch gestures to update zoom between the bounds specified by `config`.\n * When the effective zoom changes, `setZoom` is called and `callbacks.onChange` is invoked with the new and previous zoom values.\n *\n * @param element - The target HTMLElement to attach touch listeners to.\n * @param getZoom - Function that returns the current zoom level.\n * @param setZoom - Function called with the new zoom level when it changes.\n * @param config - Zoom bounds (`min` and `max`) used to clamp the computed zoom.\n * @param callbacks - Optional callbacks; `onChange(newZoom, previousZoom)` is called when zoom changes.\n * @returns A function that removes the attached touch listeners from `element`.\n */\nexport function createPinchZoomHandler(\n\telement: HTMLElement,\n\tgetZoom: () => number,\n\tsetZoom: (zoom: number) => void,\n\tconfig: ZoomConfig,\n\tcallbacks?: ZoomCallbacks,\n): () => void {\n\tlet initialDistance = 0;\n\tlet initialZoom = 1;\n\n\tconst getDistance = (touches: TouchList): number => {\n\t\tif (touches.length < 2) return 0;\n\t\tconst touch1 = touches[0];\n\t\tconst touch2 = touches[1];\n\t\tif (!touch1 || !touch2) return 0;\n\t\tconst dx = touch1.clientX - touch2.clientX;\n\t\tconst dy = touch1.clientY - touch2.clientY;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t};\n\n\tconst handleTouchStart = (e: TouchEvent) => {\n\t\tif (e.touches.length === 2) {\n\t\t\te.preventDefault();\n\t\t\tinitialDistance = getDistance(e.touches);\n\t\t\tinitialZoom = getZoom();\n\t\t}\n\t};\n\n\tconst handleTouchMove = (e: TouchEvent) => {\n\t\tif (e.touches.length === 2 && initialDistance > 0) {\n\t\t\te.preventDefault();\n\n\t\t\tconst currentDistance = getDistance(e.touches);\n\t\t\tconst scale = currentDistance / initialDistance;\n\t\t\tconst previousZoom = getZoom();\n\t\t\tconst newZoom = clamp(initialZoom * scale, config.min, config.max);\n\n\t\t\tif (newZoom !== previousZoom) {\n\t\t\t\tsetZoom(newZoom);\n\t\t\t\tcallbacks?.onChange?.(newZoom, previousZoom);\n\t\t\t}\n\t\t}\n\t};\n\n\tconst handleTouchEnd = () => {\n\t\tinitialDistance = 0;\n\t};\n\n\telement.addEventListener(\"touchstart\", handleTouchStart, { passive: false });\n\telement.addEventListener(\"touchmove\", handleTouchMove, { passive: false });\n\telement.addEventListener(\"touchend\", handleTouchEnd);\n\n\treturn () => {\n\t\telement.removeEventListener(\"touchstart\", handleTouchStart);\n\t\telement.removeEventListener(\"touchmove\", handleTouchMove);\n\t\telement.removeEventListener(\"touchend\", handleTouchEnd);\n\t};\n}\n",
    "/**\n * Creates an HTMLImageElement for the given URL and loads its image data.\n *\n * If `url` does not start with `\"data:\"`, the image's `crossOrigin` is set to `\"anonymous\"`. The returned operation rejects with an `Error` if the image fails to load.\n *\n * @param url - The image URL or data URL to load.\n * @returns The loaded `HTMLImageElement`.\n */\nexport function loadImage(url: string): Promise<HTMLImageElement> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst img = new Image();\n\n\t\t// Only set crossOrigin for actual URLs, not data URLs\n\t\tif (!url.startsWith(\"data:\")) {\n\t\t\timg.crossOrigin = \"anonymous\";\n\t\t}\n\n\t\timg.onload = () => resolve(img);\n\t\timg.onerror = () => reject(new Error(`Failed to load image: ${url}`));\n\n\t\timg.src = url;\n\t});\n}\n\n/**\n * Convert a File or Blob into a data URL string.\n *\n * @returns The file contents encoded as a data URL string.\n * @throws If reading the file fails.\n * @throws If the FileReader produces a non-string result.\n */\nexport function fileToDataUrl(file: File | Blob): Promise<string> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst reader = new FileReader();\n\n\t\treader.onload = () => {\n\t\t\tif (typeof reader.result === \"string\") {\n\t\t\t\tresolve(reader.result);\n\t\t\t} else {\n\t\t\t\treject(new Error(\"Failed to read file as data URL\"));\n\t\t\t}\n\t\t};\n\n\t\treader.onerror = () => reject(new Error(\"Failed to read file\"));\n\n\t\treader.readAsDataURL(file);\n\t});\n}\n\n/**\n * Returns the natural width and height of the provided image element.\n *\n * @returns An object with `width` set to the image's naturalWidth and `height` set to the image's naturalHeight\n */\nexport function getImageDimensions(img: HTMLImageElement): {\n\twidth: number;\n\theight: number;\n} {\n\treturn {\n\t\twidth: img.naturalWidth,\n\t\theight: img.naturalHeight,\n\t};\n}\n\n/**\n * Compute the aspect ratio of dimensions as width divided by height.\n *\n * @returns The aspect ratio (`width / height`).\n */\nexport function aspectRatio(width: number, height: number): number {\n\treturn width / height;\n}\n\n/**\n * Compute the scale factor that fills a viewport with an image.\n *\n * @param imageWidth - Image width in pixels\n * @param imageHeight - Image height in pixels\n * @param viewportWidth - Viewport width in pixels\n * @param viewportHeight - Viewport height in pixels\n * @returns The scale factor to apply to the image so it fills the viewport; values > 1 enlarge the image, values < 1 shrink it\n */\nexport function calculateInitialZoom(\n\timageWidth: number,\n\timageHeight: number,\n\tviewportWidth: number,\n\tviewportHeight: number,\n): number {\n\tconst widthRatio = viewportWidth / imageWidth;\n\tconst heightRatio = viewportHeight / imageHeight;\n\n\t// Use the larger ratio to ensure viewport is filled\n\treturn Math.max(widthRatio, heightRatio);\n}\n",
    "import type { CropPoints, PointsArray } from \"../types\";\n\n// Re-export for convenience\nexport type { PointsArray };\n\n/**\n * Input type that accepts either format\n */\nexport type PointsInput = CropPoints | PointsArray;\n\n/**\n * Normalize a points input into a CropPoints object.\n *\n * @param points - An array [topLeftX, topLeftY, bottomRightX, bottomRightY], a CropPoints object, or `undefined`.\n * @returns A CropPoints object corresponding to `points`, or `undefined` if `points` is `undefined`.\n * @throws Error if `points` is an array whose length is not exactly 4.\n */\nexport function normalizePoints(\n\tpoints: PointsInput | undefined,\n): CropPoints | undefined {\n\tif (points === undefined) {\n\t\treturn undefined;\n\t}\n\n\tif (Array.isArray(points)) {\n\t\tif (points.length !== 4) {\n\t\t\tthrow new Error(\n\t\t\t\t\"PointsArray must have exactly 4 elements: [topLeftX, topLeftY, bottomRightX, bottomRightY]\",\n\t\t\t);\n\t\t}\n\t\treturn {\n\t\t\ttopLeftX: points[0],\n\t\t\ttopLeftY: points[1],\n\t\t\tbottomRightX: points[2],\n\t\t\tbottomRightY: points[3],\n\t\t};\n\t}\n\n\treturn points;\n}\n\n/**\n * Converts a CropPoints object into a PointsArray.\n *\n * @param points - Object with `topLeftX`, `topLeftY`, `bottomRightX`, and `bottomRightY` coordinates\n * @returns A PointsArray in the order [topLeftX, topLeftY, bottomRightX, bottomRightY]\n */\nexport function pointsToArray(points: CropPoints): PointsArray {\n\treturn [\n\t\tpoints.topLeftX,\n\t\tpoints.topLeftY,\n\t\tpoints.bottomRightX,\n\t\tpoints.bottomRightY,\n\t];\n}\n",
    "import type {\n\tBindOptions,\n\tBoundary,\n\tCropPoints,\n\tCroppieData,\n\tCroppieEventHandler,\n\tCroppieEvents,\n\tCroppieOptions,\n\tResultOptions,\n\tTransformState,\n\tViewport,\n\tZoomConfig,\n} from \"./types.ts\";\n\nimport {\n\tcreateBoundary,\n\tcreateContainer,\n\tcreateOverlay,\n\tcreatePreview,\n\tcreateSliderContainer,\n\tcreateViewport,\n\tcreateZoomSlider,\n} from \"./ui/index.ts\";\n\nimport {\n\tcanvasToBase64,\n\tcanvasToBlob,\n\tdrawCroppedImage,\n} from \"./canvas/index.ts\";\nimport { createDragHandler } from \"./input/drag.ts\";\nimport {\n\tcreatePinchZoomHandler,\n\tcreateWheelZoomHandler,\n} from \"./input/zoom.ts\";\nimport {\n\tcalculateInitialZoom,\n\tclamp,\n\tfileToDataUrl,\n\tloadImage,\n\tnormalizePoints,\n\tsetTransform,\n} from \"./utils/index.ts\";\n\nconst DEFAULT_ZOOM: ZoomConfig = {\n\tmin: 0.1,\n\tmax: 10,\n};\n\n/**\n * Modern, TypeScript-first image cropper.\n *\n * @example\n * ```ts\n * const croppie = new Croppie(element, {\n *   viewport: { width: 200, height: 200, type: 'circle' }\n * })\n *\n * await croppie.bind({ url: 'image.jpg' })\n * const blob = await croppie.result({ type: 'blob' })\n * ```\n */\nexport class Croppie {\n\tprivate readonly element: HTMLElement;\n\tprivate readonly options: Required<\n\t\tPick<\n\t\t\tCroppieOptions,\n\t\t\t\"viewport\" | \"boundary\" | \"showZoomer\" | \"mouseWheelZoom\"\n\t\t>\n\t> &\n\t\tCroppieOptions;\n\n\t// DOM elements\n\tprivate container: HTMLDivElement | null = null;\n\tprivate boundaryEl: HTMLDivElement | null = null;\n\tprivate viewportEl: HTMLDivElement | null = null;\n\tprivate overlayEl: HTMLDivElement | null = null;\n\tprivate previewEl: HTMLImageElement | null = null;\n\tprivate sliderEl: HTMLInputElement | null = null;\n\n\t// State\n\tprivate image: HTMLImageElement | null = null;\n\tprivate transform: TransformState = { x: 0, y: 0, scale: 1 };\n\tprivate zoomConfig: ZoomConfig;\n\tprivate effectiveMinZoom = 0.1;\n\n\t// Event handlers\n\tprivate eventHandlers: Map<\n\t\tkeyof CroppieEvents,\n\t\tSet<CroppieEventHandler<keyof CroppieEvents>>\n\t> = new Map();\n\n\t// Cleanup functions\n\tprivate cleanupFns: Array<() => void> = [];\n\n\tconstructor(element: HTMLElement, options: CroppieOptions) {\n\t\tthis.element = element;\n\n\t\t// Calculate default boundary (viewport + 100px padding)\n\t\tconst defaultBoundary: Boundary = {\n\t\t\twidth: options.viewport.width + 100,\n\t\t\theight: options.viewport.height + 100,\n\t\t};\n\n\t\tthis.options = {\n\t\t\t...options,\n\t\t\tboundary: options.boundary ?? defaultBoundary,\n\t\t\tshowZoomer: options.showZoomer ?? true,\n\t\t\tmouseWheelZoom: options.mouseWheelZoom ?? true,\n\t\t};\n\n\t\tthis.zoomConfig = {\n\t\t\t...DEFAULT_ZOOM,\n\t\t\t...options.zoom,\n\t\t};\n\n\t\t// Deprecation warning for v2.6 migration\n\t\tif (options.enableOrientation !== undefined) {\n\t\t\tconsole.warn(\n\t\t\t\t\"[@bayinformatics/croppie] enableOrientation is deprecated and has no effect. Rotation support is planned for a future release.\",\n\t\t\t);\n\t\t}\n\n\t\tthis.createElements();\n\t\tthis.attachEventHandlers();\n\t}\n\n\t/**\n\t * Creates all DOM elements\n\t */\n\tprivate createElements(): void {\n\t\tthis.container = createContainer(this.options.customClass);\n\t\tthis.boundaryEl = createBoundary(this.options.boundary);\n\t\tthis.viewportEl = createViewport(this.options.viewport);\n\t\tthis.overlayEl = createOverlay(\n\t\t\tthis.options.boundary,\n\t\t\tthis.options.viewport,\n\t\t);\n\t\tthis.previewEl = createPreview();\n\n\t\t// Assemble the DOM tree\n\t\tthis.boundaryEl.appendChild(this.previewEl);\n\t\tthis.boundaryEl.appendChild(this.overlayEl);\n\t\tthis.boundaryEl.appendChild(this.viewportEl);\n\t\tthis.container.appendChild(this.boundaryEl);\n\n\t\t// Add zoom slider if enabled\n\t\tif (this.options.showZoomer) {\n\t\t\tconst sliderWrap = createSliderContainer();\n\t\t\tthis.sliderEl = createZoomSlider(\n\t\t\t\tthis.zoomConfig.min,\n\t\t\t\tthis.zoomConfig.max,\n\t\t\t\tthis.transform.scale,\n\t\t\t);\n\t\t\tsliderWrap.appendChild(this.sliderEl);\n\t\t\tthis.container.appendChild(sliderWrap);\n\n\t\t\t// Slider input handler\n\t\t\tconst handleSliderInput = () => {\n\t\t\t\tif (this.sliderEl) {\n\t\t\t\t\tconst previousZoom = this.transform.scale;\n\t\t\t\t\tthis.setZoom(Number.parseFloat(this.sliderEl.value));\n\t\t\t\t\tthis.emitEvent(\"zoom\", { zoom: this.transform.scale, previousZoom });\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.sliderEl.addEventListener(\"input\", handleSliderInput);\n\t\t\tthis.cleanupFns.push(() => {\n\t\t\t\tthis.sliderEl?.removeEventListener(\"input\", handleSliderInput);\n\t\t\t});\n\t\t}\n\n\t\tthis.element.appendChild(this.container);\n\t}\n\n\t/**\n\t * Attaches drag and zoom event handlers\n\t */\n\tprivate attachEventHandlers(): void {\n\t\tif (!this.boundaryEl || !this.previewEl) return;\n\n\t\t// Drag handler\n\t\tconst dragCleanup = createDragHandler(\n\t\t\tthis.boundaryEl,\n\t\t\t() => this.transform,\n\t\t\t(x, y) => {\n\t\t\t\tthis.transform.x = x;\n\t\t\t\tthis.transform.y = y;\n\t\t\t\tthis.updateTransform();\n\t\t\t\tthis.emitUpdate();\n\t\t\t},\n\t\t);\n\t\tthis.cleanupFns.push(dragCleanup);\n\n\t\t// Wheel zoom handler\n\t\tif (this.options.mouseWheelZoom) {\n\t\t\tconst requireCtrl = this.options.mouseWheelZoom === \"ctrl\";\n\t\t\tconst wheelCleanup = createWheelZoomHandler(\n\t\t\t\tthis.boundaryEl,\n\t\t\t\t() => this.transform.scale,\n\t\t\t\t(zoom) => this.setZoom(zoom),\n\t\t\t\tthis.zoomConfig,\n\t\t\t\t{\n\t\t\t\t\tonChange: (_zoom, previousZoom) => {\n\t\t\t\t\t\t// Emit the actual clamped zoom value (setZoom clamps to effectiveMinZoom)\n\t\t\t\t\t\tthis.emitEvent(\"zoom\", {\n\t\t\t\t\t\t\tzoom: this.transform.scale,\n\t\t\t\t\t\t\tpreviousZoom,\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\trequireCtrl,\n\t\t\t);\n\t\t\tthis.cleanupFns.push(wheelCleanup);\n\t\t}\n\n\t\t// Pinch zoom handler\n\t\tconst pinchCleanup = createPinchZoomHandler(\n\t\t\tthis.boundaryEl,\n\t\t\t() => this.transform.scale,\n\t\t\t(zoom) => this.setZoom(zoom),\n\t\t\tthis.zoomConfig,\n\t\t\t{\n\t\t\t\tonChange: (_zoom, previousZoom) => {\n\t\t\t\t\t// Emit the actual clamped zoom value (setZoom clamps to effectiveMinZoom)\n\t\t\t\t\tthis.emitEvent(\"zoom\", { zoom: this.transform.scale, previousZoom });\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\t\tthis.cleanupFns.push(pinchCleanup);\n\t}\n\n\t/**\n\t * Loads an image into the cropper\n\t */\n\tasync bind(options: BindOptions | string): Promise<void> {\n\t\tconst bindOptions: BindOptions =\n\t\t\ttypeof options === \"string\" ? { url: options } : options;\n\n\t\tthis.image = await loadImage(bindOptions.url);\n\n\t\tif (this.previewEl) {\n\t\t\t// Use the loaded image's src to ensure preview matches the image we crop from\n\t\t\t// (important for URLs that return different content on each request)\n\t\t\tthis.previewEl.src = this.image.src;\n\t\t}\n\n\t\t// Calculate minimum zoom to cover viewport\n\t\tconst coverageZoom = calculateInitialZoom(\n\t\t\tthis.image.naturalWidth,\n\t\t\tthis.image.naturalHeight,\n\t\t\tthis.options.viewport.width,\n\t\t\tthis.options.viewport.height,\n\t\t);\n\n\t\t// Calculate effective min zoom (enforce coverage by default)\n\t\tif (this.zoomConfig.enforceMinimumCoverage !== false) {\n\t\t\tthis.effectiveMinZoom = Math.max(this.zoomConfig.min, coverageZoom);\n\t\t} else {\n\t\t\tthis.effectiveMinZoom = this.zoomConfig.min;\n\t\t}\n\n\t\t// Calculate initial zoom\n\t\tconst initialZoom = bindOptions.zoom ?? coverageZoom;\n\n\t\tthis.transform = {\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\tscale: clamp(initialZoom, this.effectiveMinZoom, this.zoomConfig.max),\n\t\t};\n\n\t\t// Update slider min to reflect effective minimum\n\t\tif (this.sliderEl) {\n\t\t\tthis.sliderEl.min = String(this.effectiveMinZoom);\n\t\t}\n\n\t\t// Apply initial points if provided\n\t\tif (bindOptions.points) {\n\t\t\tconst normalizedPoints = normalizePoints(bindOptions.points);\n\t\t\tif (normalizedPoints) {\n\t\t\t\t// TODO: Calculate transform from points - not yet implemented\n\t\t\t\tconsole.warn(\n\t\t\t\t\t\"[@bayinformatics/croppie] Initial points are not yet fully supported. Provided:\",\n\t\t\t\t\tnormalizedPoints,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tthis.updateTransform();\n\t\tthis.updateSlider();\n\t}\n\n\t/**\n\t * Binds a File or Blob to the cropper\n\t */\n\tasync bindFile(file: File | Blob): Promise<void> {\n\t\tconst dataUrl = await fileToDataUrl(file);\n\t\tawait this.bind({ url: dataUrl });\n\t}\n\n\t/**\n\t * Gets the current cropped result\n\t */\n\tasync result(\n\t\toptions: ResultOptions,\n\t): Promise<Blob | string | HTMLCanvasElement> {\n\t\tif (!this.image) {\n\t\t\tthrow new Error(\"No image bound\");\n\t\t}\n\n\t\tconst points = this.getPoints();\n\t\tconst viewport = this.options.viewport;\n\n\t\t// Determine output size\n\t\tlet outputWidth: number;\n\t\tlet outputHeight: number;\n\n\t\tif (options.size === \"viewport\") {\n\t\t\toutputWidth = viewport.width;\n\t\t\toutputHeight = viewport.height;\n\t\t} else if (options.size === \"original\") {\n\t\t\toutputWidth = points.bottomRightX - points.topLeftX;\n\t\t\toutputHeight = points.bottomRightY - points.topLeftY;\n\t\t} else if (options.size) {\n\t\t\toutputWidth = options.size.width;\n\t\t\toutputHeight = options.size.height;\n\t\t} else {\n\t\t\toutputWidth = viewport.width;\n\t\t\toutputHeight = viewport.height;\n\t\t}\n\n\t\tconst canvas = drawCroppedImage(\n\t\t\tthis.image,\n\t\t\tpoints,\n\t\t\toutputWidth,\n\t\t\toutputHeight,\n\t\t\t{\n\t\t\t\tcircle: options.circle ?? viewport.type === \"circle\",\n\t\t\t\tbackgroundColor: options.backgroundColor,\n\t\t\t},\n\t\t);\n\n\t\tswitch (options.type) {\n\t\t\tcase \"canvas\":\n\t\t\t\treturn canvas;\n\t\t\tcase \"base64\":\n\t\t\t\treturn canvasToBase64(canvas, options.format, options.quality);\n\t\t\tcase \"blob\":\n\t\t\t\treturn canvasToBlob(canvas, options.format, options.quality);\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown result type: ${options.type}`);\n\t\t}\n\t}\n\n\t/**\n\t * Gets the current crop data\n\t */\n\tget(): CroppieData {\n\t\treturn {\n\t\t\tpoints: this.getPoints(),\n\t\t\tzoom: this.transform.scale,\n\t\t};\n\t}\n\n\t/**\n\t * Gets the current zoom level\n\t */\n\tget zoom(): number {\n\t\treturn this.transform.scale;\n\t}\n\n\t/**\n\t * Sets the zoom level\n\t */\n\tset zoom(value: number) {\n\t\tthis.setZoom(value);\n\t}\n\n\t/**\n\t * Sets the zoom level with clamping\n\t */\n\tsetZoom(value: number): void {\n\t\tconst previousZoom = this.transform.scale;\n\t\tthis.transform.scale = clamp(\n\t\t\tvalue,\n\t\t\tthis.effectiveMinZoom,\n\t\t\tthis.zoomConfig.max,\n\t\t);\n\t\tthis.updateTransform();\n\t\tthis.updateSlider();\n\n\t\tif (previousZoom !== this.transform.scale) {\n\t\t\tthis.emitUpdate();\n\t\t}\n\t}\n\n\t/**\n\t * Rotates the image by 90 degree increments\n\t */\n\trotate(degrees: 90 | 180 | 270 | -90): void {\n\t\t// TODO: Implement rotation\n\t\tconsole.warn(\"Rotation not yet implemented:\", degrees);\n\t}\n\n\t/**\n\t * Resets the cropper to initial state\n\t */\n\treset(): void {\n\t\tif (this.image) {\n\t\t\tconst coverageZoom = calculateInitialZoom(\n\t\t\t\tthis.image.naturalWidth,\n\t\t\t\tthis.image.naturalHeight,\n\t\t\t\tthis.options.viewport.width,\n\t\t\t\tthis.options.viewport.height,\n\t\t\t);\n\n\t\t\t// Clamp to effective minimum zoom (same logic as bind)\n\t\t\tconst initialZoom = clamp(\n\t\t\t\tcoverageZoom,\n\t\t\t\tthis.effectiveMinZoom,\n\t\t\t\tthis.zoomConfig.max,\n\t\t\t);\n\n\t\t\tthis.transform = { x: 0, y: 0, scale: initialZoom };\n\t\t\tthis.updateTransform();\n\t\t\tthis.updateSlider();\n\t\t\tthis.emitUpdate();\n\t\t}\n\t}\n\n\t/**\n\t * Destroys the cropper and cleans up\n\t */\n\tdestroy(): void {\n\t\t// Run all cleanup functions\n\t\tfor (const cleanup of this.cleanupFns) {\n\t\t\tcleanup();\n\t\t}\n\t\tthis.cleanupFns = [];\n\n\t\t// Clear event handlers\n\t\tthis.eventHandlers.clear();\n\n\t\t// Remove DOM elements\n\t\tif (this.container?.parentNode) {\n\t\t\tthis.container.parentNode.removeChild(this.container);\n\t\t}\n\n\t\tthis.container = null;\n\t\tthis.boundaryEl = null;\n\t\tthis.viewportEl = null;\n\t\tthis.overlayEl = null;\n\t\tthis.previewEl = null;\n\t\tthis.sliderEl = null;\n\t\tthis.image = null;\n\t}\n\n\t/**\n\t * Registers an event handler\n\t */\n\ton<K extends keyof CroppieEvents>(\n\t\tevent: K,\n\t\thandler: CroppieEventHandler<K>,\n\t): void {\n\t\tif (!this.eventHandlers.has(event)) {\n\t\t\tthis.eventHandlers.set(event, new Set());\n\t\t}\n\t\tthis.eventHandlers\n\t\t\t.get(event)\n\t\t\t?.add(handler as CroppieEventHandler<keyof CroppieEvents>);\n\t}\n\n\t/**\n\t * Removes an event handler\n\t */\n\toff<K extends keyof CroppieEvents>(\n\t\tevent: K,\n\t\thandler: CroppieEventHandler<K>,\n\t): void {\n\t\tthis.eventHandlers\n\t\t\t.get(event)\n\t\t\t?.delete(handler as CroppieEventHandler<keyof CroppieEvents>);\n\t}\n\n\t/**\n\t * Updates the CSS transform on the preview element\n\t */\n\tprivate updateTransform(): void {\n\t\tif (this.previewEl) {\n\t\t\t// Center the image in the boundary\n\t\t\tconst boundaryWidth = this.options.boundary.width;\n\t\t\tconst boundaryHeight = this.options.boundary.height;\n\t\t\tconst imageWidth = this.image?.naturalWidth ?? 0;\n\t\t\tconst imageHeight = this.image?.naturalHeight ?? 0;\n\n\t\t\tconst scaledWidth = imageWidth * this.transform.scale;\n\t\t\tconst scaledHeight = imageHeight * this.transform.scale;\n\n\t\t\tconst centerX = (boundaryWidth - scaledWidth) / 2 + this.transform.x;\n\t\t\tconst centerY = (boundaryHeight - scaledHeight) / 2 + this.transform.y;\n\n\t\t\tsetTransform(this.previewEl, centerX, centerY, this.transform.scale);\n\t\t}\n\t}\n\n\t/**\n\t * Updates the slider value to match current zoom\n\t */\n\tprivate updateSlider(): void {\n\t\tif (this.sliderEl) {\n\t\t\tthis.sliderEl.value = String(this.transform.scale);\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the crop points based on current transform\n\t */\n\tprivate getPoints(): CropPoints {\n\t\tif (!this.image) {\n\t\t\treturn { topLeftX: 0, topLeftY: 0, bottomRightX: 0, bottomRightY: 0 };\n\t\t}\n\n\t\tconst viewport = this.options.viewport;\n\t\tconst boundary = this.options.boundary;\n\t\tconst imageWidth = this.image.naturalWidth;\n\t\tconst imageHeight = this.image.naturalHeight;\n\n\t\t// Calculate the visible area in image coordinates\n\t\tconst scaledWidth = imageWidth * this.transform.scale;\n\t\tconst scaledHeight = imageHeight * this.transform.scale;\n\n\t\tconst imageLeft = (boundary.width - scaledWidth) / 2 + this.transform.x;\n\t\tconst imageTop = (boundary.height - scaledHeight) / 2 + this.transform.y;\n\n\t\tconst viewportLeft = (boundary.width - viewport.width) / 2;\n\t\tconst viewportTop = (boundary.height - viewport.height) / 2;\n\n\t\t// Convert viewport coordinates to image coordinates\n\t\tconst topLeftX = (viewportLeft - imageLeft) / this.transform.scale;\n\t\tconst topLeftY = (viewportTop - imageTop) / this.transform.scale;\n\t\tconst bottomRightX = topLeftX + viewport.width / this.transform.scale;\n\t\tconst bottomRightY = topLeftY + viewport.height / this.transform.scale;\n\n\t\treturn {\n\t\t\ttopLeftX: Math.max(0, topLeftX),\n\t\t\ttopLeftY: Math.max(0, topLeftY),\n\t\t\tbottomRightX: Math.min(imageWidth, bottomRightX),\n\t\t\tbottomRightY: Math.min(imageHeight, bottomRightY),\n\t\t};\n\t}\n\n\t/**\n\t * Emits an update event\n\t */\n\tprivate emitUpdate(): void {\n\t\tthis.emitEvent(\"update\", this.get());\n\t}\n\n\t/**\n\t * Emits an event to all registered handlers\n\t */\n\tprivate emitEvent<K extends keyof CroppieEvents>(\n\t\tevent: K,\n\t\tdata: CroppieEvents[K],\n\t): void {\n\t\tconst handlers = this.eventHandlers.get(event);\n\t\tif (handlers) {\n\t\t\tfor (const handler of handlers) {\n\t\t\t\t(handler as CroppieEventHandler<K>)(data);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  ],
  "mappings": "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",
  "debugId": "6AA065CBDCEC07B964756E2164756E21",
  "names": []
}