function R(G,J){let K=document.createElement(G);if(J?.className)K.className=J.className;if(J?.attributes)for(let[N,Q]of Object.entries(J.attributes))K.setAttribute(N,Q);if(J?.styles)Object.assign(K.style,J.styles);return K}function U(G,J,K,N){G.style.transform=`translate(${J}px, ${K}px) scale(${N})`}function j(G){return R("div",{className:`croppie-container${G?` ${G}`:""}`})}function x(G){return R("div",{className:"cr-boundary",styles:{width:`${G.width}px`,height:`${G.height}px`,position:"relative",overflow:"hidden"}})}function X(G){return R("div",{className:`cr-viewport cr-vp-${G.type}`,styles:{width:`${G.width}px`,height:`${G.height}px`,position:"absolute",top:"50%",left:"50%",transform:"translate(-50%, -50%)",pointerEvents:"none",borderRadius:G.type==="circle"?"50%":"0"}})}function Y(G,J){let K=R("div",{className:"cr-overlay",styles:{position:"absolute",top:"0",left:"0",width:"100%",height:"100%",pointerEvents:"none"}}),N=v(G,J);return K.style.background="rgba(0, 0, 0, 0.5)",K.style.maskImage=N,K.style.webkitMaskImage=N,K}function v(G,J){let K=G.width/2,N=G.height/2;if(J.type==="circle"){let B=J.width/2;return`radial-gradient(circle ${B}px at ${K}px ${N}px, transparent ${B}px, black ${B}px)`}let Q=K-J.width/2,V=K+J.width/2,$=N-J.height/2,_=N+J.height/2;return`
    linear-gradient(to right, black ${Q}px, transparent ${Q}px, transparent ${V}px, black ${V}px),
    linear-gradient(to bottom, black ${$}px, transparent ${$}px, transparent ${_}px, black ${_}px)
  `}function E(){return R("img",{className:"cr-image",attributes:{alt:"Cropper image",draggable:"false"},styles:{position:"absolute",top:"0",left:"0",transformOrigin:"0 0",maxWidth:"none",maxHeight:"none"}})}function L(G,J,K){return R("input",{className:"cr-slider",attributes:{type:"range",min:String(G),max:String(J),step:"0.01",value:String(K)}})}function z(){return R("div",{className:"cr-slider-wrap"})}function C(G,J,K,N,Q){let V=document.createElement("canvas");V.width=K,V.height=N;let $=V.getContext("2d");if(!$)throw Error("Failed to get 2D context");if(Q?.backgroundColor)$.fillStyle=Q.backgroundColor,$.fillRect(0,0,K,N);if(Q?.circle)$.beginPath(),$.arc(K/2,N/2,K/2,0,Math.PI*2),$.closePath(),$.clip();let _=J.bottomRightX-J.topLeftX,B=J.bottomRightY-J.topLeftY;return $.drawImage(G,J.topLeftX,J.topLeftY,_,B,0,0,K,N),V}function k(G,J="png",K=0.92){return new Promise((N,Q)=>{let V=`image/${J}`;G.toBlob(($)=>{if($)N($);else Q(Error("Failed to create blob from canvas"))},V,K)})}function T(G,J="png",K=0.92){let N=`image/${J}`;return G.toDataURL(N,K)}function b(G,J,K,N){let Q={isDragging:!1,startX:0,startY:0,startTransformX:0,startTransformY:0},V=(B)=>{if(B.button!==0)return;Q.isDragging=!0,Q.startX=B.clientX,Q.startY=B.clientY;let A=J();Q.startTransformX=A.x,Q.startTransformY=A.y,G.setPointerCapture(B.pointerId),G.style.cursor="grabbing",N?.onStart?.(A)},$=(B)=>{if(!Q.isDragging)return;let A=B.clientX-Q.startX,I=B.clientY-Q.startY,F=Q.startTransformX+A,S=Q.startTransformY+I;K(F,S);let M=J();N?.onMove?.(M)},_=(B)=>{if(!Q.isDragging)return;Q.isDragging=!1,G.releasePointerCapture(B.pointerId),G.style.cursor="grab";let A=J();N?.onEnd?.(A)};return G.addEventListener("pointerdown",V),G.addEventListener("pointermove",$),G.addEventListener("pointerup",_),G.addEventListener("pointercancel",_),G.style.cursor="grab",G.style.touchAction="none",()=>{G.removeEventListener("pointerdown",V),G.removeEventListener("pointermove",$),G.removeEventListener("pointerup",_),G.removeEventListener("pointercancel",_)}}function q(G,J,K){return Math.min(Math.max(G,J),K)}function f(G,J,K,N,Q,V=!1){let $=(_)=>{if(V&&!_.ctrlKey)return;_.preventDefault();let B=J(),A=_.deltaY>0?-0.1:0.1,I=q(B+A,N.min,N.max);if(I!==B)K(I),Q?.onChange?.(I,B)};return G.addEventListener("wheel",$,{passive:!1}),()=>{G.removeEventListener("wheel",$)}}function w(G,J,K,N,Q){let V=0,$=1,_=(F)=>{if(F.length<2)return 0;let S=F.item(0),M=F.item(1);if(!S||!M)return 0;let O=S.clientX-M.clientX,D=S.clientY-M.clientY;return Math.sqrt(O*O+D*D)},B=(F)=>{if(F.touches.length===2)F.preventDefault(),V=_(F.touches),$=J()},A=(F)=>{if(F.touches.length===2&&V>0){F.preventDefault();let M=_(F.touches)/V,O=J(),D=q($*M,N.min,N.max);if(D!==O)K(D),Q?.onChange?.(D,O)}},I=()=>{V=0};return G.addEventListener("touchstart",B,{passive:!1}),G.addEventListener("touchmove",A,{passive:!1}),G.addEventListener("touchend",I),()=>{G.removeEventListener("touchstart",B),G.removeEventListener("touchmove",A),G.removeEventListener("touchend",I)}}function y(G){return new Promise((J,K)=>{let N=new Image;if(!G.startsWith("data:"))N.crossOrigin="anonymous";N.onload=()=>J(N),N.onerror=()=>K(Error(`Failed to load image: ${G}`)),N.src=G})}function H(G){return new Promise((J,K)=>{let N=new FileReader;N.onload=()=>{if(typeof N.result==="string")J(N.result);else K(Error("Failed to read file as data URL"))},N.onerror=()=>K(Error("Failed to read file")),N.readAsDataURL(G)})}function P(G,J,K,N){let Q=K/G,V=N/J;return Math.max(Q,V)}function W(G){if(G===void 0)return;if(Array.isArray(G)){if(G.length!==4)throw Error("PointsArray must have exactly 4 elements: [topLeftX, topLeftY, bottomRightX, bottomRightY]");return{topLeftX:G[0],topLeftY:G[1],bottomRightX:G[2],bottomRightY:G[3]}}return G}var g={min:0.1,max:10};class Z{element;options;container=null;boundaryEl=null;viewportEl=null;overlayEl=null;previewEl=null;sliderEl=null;image=null;transform={x:0,y:0,scale:1};zoomConfig;effectiveMinZoom=0.1;eventHandlers=new Map;cleanupFns=[];constructor(G,J){this.element=G;let K={width:J.viewport.width+100,height:J.viewport.height+100};if(this.options={...J,boundary:J.boundary??K,showZoomer:J.showZoomer??!0,mouseWheelZoom:J.mouseWheelZoom??!0},this.zoomConfig={...g,...J.zoom},J.enableOrientation!==void 0)console.warn("[@bayinformatics/croppie] enableOrientation is deprecated and has no effect. Rotation support is planned for a future release.");this.createElements(),this.attachEventHandlers()}createElements(){if(this.container=j(this.options.customClass),this.boundaryEl=x(this.options.boundary),this.viewportEl=X(this.options.viewport),this.overlayEl=Y(this.options.boundary,this.options.viewport),this.previewEl=E(),this.boundaryEl.appendChild(this.previewEl),this.boundaryEl.appendChild(this.overlayEl),this.boundaryEl.appendChild(this.viewportEl),this.container.appendChild(this.boundaryEl),this.options.showZoomer){let G=z();this.sliderEl=L(this.zoomConfig.min,this.zoomConfig.max,this.transform.scale),G.appendChild(this.sliderEl),this.container.appendChild(G);let J=()=>{if(this.sliderEl){let K=this.transform.scale;this.setZoom(Number.parseFloat(this.sliderEl.value)),this.emitEvent("zoom",{zoom:this.transform.scale,previousZoom:K})}};this.sliderEl.addEventListener("input",J),this.cleanupFns.push(()=>{this.sliderEl?.removeEventListener("input",J)})}this.element.appendChild(this.container)}attachEventHandlers(){if(!this.boundaryEl||!this.previewEl)return;let G=b(this.boundaryEl,()=>this.transform,(K,N)=>{this.transform.x=K,this.transform.y=N,this.updateTransform(),this.emitUpdate()});if(this.cleanupFns.push(G),this.options.mouseWheelZoom){let K=this.options.mouseWheelZoom==="ctrl",N=f(this.boundaryEl,()=>this.transform.scale,(Q)=>this.setZoom(Q),this.zoomConfig,{onChange:(Q,V)=>{this.emitEvent("zoom",{zoom:this.transform.scale,previousZoom:V})}},K);this.cleanupFns.push(N)}let J=w(this.boundaryEl,()=>this.transform.scale,(K)=>this.setZoom(K),this.zoomConfig,{onChange:(K,N)=>{this.emitEvent("zoom",{zoom:this.transform.scale,previousZoom:N})}});this.cleanupFns.push(J)}async bind(G){let J=typeof G==="string"?{url:G}:G;if(this.image=await y(J.url),this.previewEl)this.previewEl.src=this.image.src;let K=P(this.image.naturalWidth,this.image.naturalHeight,this.options.viewport.width,this.options.viewport.height);if(this.zoomConfig.enforceMinimumCoverage!==!1)this.effectiveMinZoom=Math.max(this.zoomConfig.min,K);else this.effectiveMinZoom=this.zoomConfig.min;let N=J.zoom??K;if(this.transform={x:0,y:0,scale:q(N,this.effectiveMinZoom,this.zoomConfig.max)},this.sliderEl)this.sliderEl.min=String(this.effectiveMinZoom);if(J.points){let Q=W(J.points);if(Q)console.warn("[@bayinformatics/croppie] Initial points are not yet fully supported. Provided:",Q)}this.updateTransform(),this.updateSlider()}async bindFile(G){let J=await H(G);await this.bind({url:J})}async result(G){if(!this.image)throw Error("No image bound");let J=this.getPoints(),K=this.options.viewport,N,Q;if(G.size==="viewport")N=K.width,Q=K.height;else if(G.size==="original")N=J.bottomRightX-J.topLeftX,Q=J.bottomRightY-J.topLeftY;else if(G.size)N=G.size.width,Q=G.size.height;else N=K.width,Q=K.height;let V=C(this.image,J,N,Q,{circle:G.circle??K.type==="circle",backgroundColor:G.backgroundColor});switch(G.type){case"canvas":return V;case"base64":return T(V,G.format,G.quality);case"blob":return k(V,G.format,G.quality);default:throw Error(`Unknown result type: ${G.type}`)}}get(){return{points:this.getPoints(),zoom:this.transform.scale}}get zoom(){return this.transform.scale}set zoom(G){this.setZoom(G)}setZoom(G){let J=this.transform.scale;if(this.transform.scale=q(G,this.effectiveMinZoom,this.zoomConfig.max),this.updateTransform(),this.updateSlider(),J!==this.transform.scale)this.emitUpdate()}rotate(G){console.warn("Rotation not yet implemented:",G)}reset(){if(this.image){let G=P(this.image.naturalWidth,this.image.naturalHeight,this.options.viewport.width,this.options.viewport.height),J=q(G,this.effectiveMinZoom,this.zoomConfig.max);this.transform={x:0,y:0,scale:J},this.updateTransform(),this.updateSlider(),this.emitUpdate()}}destroy(){for(let G of this.cleanupFns)G();if(this.cleanupFns=[],this.eventHandlers.clear(),this.container?.parentNode)this.container.parentNode.removeChild(this.container);this.container=null,this.boundaryEl=null,this.viewportEl=null,this.overlayEl=null,this.previewEl=null,this.sliderEl=null,this.image=null}on(G,J){if(!this.eventHandlers.has(G))this.eventHandlers.set(G,new Set);this.eventHandlers.get(G)?.add(J)}off(G,J){this.eventHandlers.get(G)?.delete(J)}updateTransform(){if(this.previewEl){let G=this.options.boundary.width,J=this.options.boundary.height,K=this.image?.naturalWidth??0,N=this.image?.naturalHeight??0,Q=K*this.transform.scale,V=N*this.transform.scale,$=(G-Q)/2+this.transform.x,_=(J-V)/2+this.transform.y;U(this.previewEl,$,_,this.transform.scale)}}updateSlider(){if(this.sliderEl)this.sliderEl.value=String(this.transform.scale)}getPoints(){if(!this.image)return{topLeftX:0,topLeftY:0,bottomRightX:0,bottomRightY:0};let G=this.options.viewport,J=this.options.boundary,K=this.image.naturalWidth,N=this.image.naturalHeight,Q=K*this.transform.scale,V=N*this.transform.scale,$=(J.width-Q)/2+this.transform.x,_=(J.height-V)/2+this.transform.y,B=(J.width-G.width)/2,A=(J.height-G.height)/2,I=(B-$)/this.transform.scale,F=(A-_)/this.transform.scale,S=I+G.width/this.transform.scale,M=F+G.height/this.transform.scale;return{topLeftX:Math.max(0,I),topLeftY:Math.max(0,F),bottomRightX:Math.min(K,S),bottomRightY:Math.min(N,M)}}emitUpdate(){this.emitEvent("update",this.get())}emitEvent(G,J){let K=this.eventHandlers.get(G);if(K)for(let N of K)N(J)}}export{Z as default,Z as Croppie};

//# debugId=070A7D3CA287EC5F64756E2164756E21
//# sourceMappingURL=croppie.js.map
