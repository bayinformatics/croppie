{
  "version": 3,
  "sources": ["../src/utils/dom.ts", "../src/ui/elements.ts", "../src/canvas/draw.ts", "../src/input/drag.ts", "../src/utils/clamp.ts", "../src/input/zoom.ts", "../src/utils/image.ts", "../src/utils/points.ts", "../src/Croppie.ts"],
  "sourcesContent": [
    "/**\n * Creates an HTML element with optional attributes and classes\n */\nexport function createElement<K extends keyof HTMLElementTagNameMap>(\n  tag: K,\n  options?: {\n    className?: string\n    attributes?: Record<string, string>\n    styles?: Partial<CSSStyleDeclaration>\n  },\n): HTMLElementTagNameMap[K] {\n  const element = document.createElement(tag)\n\n  if (options?.className) {\n    element.className = options.className\n  }\n\n  if (options?.attributes) {\n    for (const [key, value] of Object.entries(options.attributes)) {\n      element.setAttribute(key, value)\n    }\n  }\n\n  if (options?.styles) {\n    Object.assign(element.style, options.styles)\n  }\n\n  return element\n}\n\n/**\n * Gets the computed CSS transform matrix values\n */\nexport function getTransformValues(element: HTMLElement): {\n  x: number\n  y: number\n  scale: number\n} {\n  const style = window.getComputedStyle(element)\n  const transform = style.transform\n\n  if (!transform || transform === 'none') {\n    return { x: 0, y: 0, scale: 1 }\n  }\n\n  // matrix(a, b, c, d, tx, ty) or matrix3d(...)\n  const match = transform.match(/matrix.*\\((.+)\\)/)\n  if (!match?.[1]) {\n    return { x: 0, y: 0, scale: 1 }\n  }\n\n  const values = match[1].split(', ').map(Number)\n\n  if (values.length === 6) {\n    // 2D matrix\n    return {\n      x: values[4] ?? 0,\n      y: values[5] ?? 0,\n      scale: Math.sqrt((values[0] ?? 1) ** 2 + (values[1] ?? 0) ** 2),\n    }\n  }\n\n  // 3D matrix (16 values)\n  return {\n    x: values[12] ?? 0,\n    y: values[13] ?? 0,\n    scale: values[0] ?? 1,\n  }\n}\n\n/**\n * Applies transform to an element\n */\nexport function setTransform(element: HTMLElement, x: number, y: number, scale: number): void {\n  element.style.transform = `translate(${x}px, ${y}px) scale(${scale})`\n}\n",
    "import type { Boundary, Viewport, ViewportType } from '../types.ts'\nimport { createElement } from '../utils/dom.ts'\n\n/**\n * Creates the main container element\n */\nexport function createContainer(customClass?: string): HTMLDivElement {\n  const container = createElement('div', {\n    className: `croppie-container${customClass ? ` ${customClass}` : ''}`,\n  })\n  return container\n}\n\n/**\n * Creates the boundary element (outer container)\n */\nexport function createBoundary(boundary: Boundary): HTMLDivElement {\n  const element = createElement('div', {\n    className: 'cr-boundary',\n    styles: {\n      width: `${boundary.width}px`,\n      height: `${boundary.height}px`,\n      position: 'relative',\n      overflow: 'hidden',\n    },\n  })\n  return element\n}\n\n/**\n * Creates the viewport element (crop area overlay)\n */\nexport function createViewport(viewport: Viewport): HTMLDivElement {\n  const element = createElement('div', {\n    className: `cr-viewport cr-vp-${viewport.type}`,\n    styles: {\n      width: `${viewport.width}px`,\n      height: `${viewport.height}px`,\n      position: 'absolute',\n      top: '50%',\n      left: '50%',\n      transform: 'translate(-50%, -50%)',\n      pointerEvents: 'none',\n      borderRadius: viewport.type === 'circle' ? '50%' : '0',\n    },\n  })\n  return element\n}\n\n/**\n * Creates the overlay element (darkened area outside viewport)\n */\nexport function createOverlay(boundary: Boundary, viewport: Viewport): HTMLDivElement {\n  const element = createElement('div', {\n    className: 'cr-overlay',\n    styles: {\n      position: 'absolute',\n      top: '0',\n      left: '0',\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n    },\n  })\n\n  // The overlay uses a CSS mask or clip-path to create the cutout\n  const maskImage = createMaskImage(boundary, viewport)\n  element.style.background = 'rgba(0, 0, 0, 0.5)'\n  element.style.maskImage = maskImage\n  element.style.webkitMaskImage = maskImage\n\n  return element\n}\n\n/**\n * Creates a CSS mask image for the viewport cutout\n */\nfunction createMaskImage(boundary: Boundary, viewport: Viewport): string {\n  const centerX = boundary.width / 2\n  const centerY = boundary.height / 2\n\n  if (viewport.type === 'circle') {\n    const radius = viewport.width / 2\n    // Create a radial gradient that's transparent in the center\n    return `radial-gradient(circle ${radius}px at ${centerX}px ${centerY}px, transparent ${radius}px, black ${radius}px)`\n  }\n\n  // For square, use a more complex gradient\n  const left = centerX - viewport.width / 2\n  const right = centerX + viewport.width / 2\n  const top = centerY - viewport.height / 2\n  const bottom = centerY + viewport.height / 2\n\n  // This creates a rectangular hole using CSS gradients\n  return `\n    linear-gradient(to right, black ${left}px, transparent ${left}px, transparent ${right}px, black ${right}px),\n    linear-gradient(to bottom, black ${top}px, transparent ${top}px, transparent ${bottom}px, black ${bottom}px)\n  `\n}\n\n/**\n * Creates the image preview element\n */\nexport function createPreview(): HTMLImageElement {\n  const element = createElement('img', {\n    className: 'cr-image',\n    attributes: {\n      alt: 'Cropper image',\n      draggable: 'false',\n    },\n    styles: {\n      position: 'absolute',\n      top: '0',\n      left: '0',\n      transformOrigin: '0 0',\n      maxWidth: 'none',\n      maxHeight: 'none',\n    },\n  })\n  return element\n}\n\n/**\n * Creates the zoom slider element\n */\nexport function createZoomSlider(min: number, max: number, value: number): HTMLInputElement {\n  const element = createElement('input', {\n    className: 'cr-slider',\n    attributes: {\n      type: 'range',\n      min: String(min),\n      max: String(max),\n      step: '0.01',\n      value: String(value),\n    },\n  })\n  return element\n}\n\n/**\n * Creates the slider container\n */\nexport function createSliderContainer(): HTMLDivElement {\n  return createElement('div', {\n    className: 'cr-slider-wrap',\n  })\n}\n",
    "import type { CropPoints, OutputFormat } from '../types.ts'\n\n/**\n * Draws an image to a canvas with the specified crop and dimensions\n */\nexport function drawCroppedImage(\n  image: HTMLImageElement,\n  points: CropPoints,\n  outputWidth: number,\n  outputHeight: number,\n  options?: {\n    circle?: boolean\n    backgroundColor?: string\n  },\n): HTMLCanvasElement {\n  const canvas = document.createElement('canvas')\n  canvas.width = outputWidth\n  canvas.height = outputHeight\n\n  const ctx = canvas.getContext('2d')\n  if (!ctx) {\n    throw new Error('Failed to get 2D context')\n  }\n\n  // Fill background if specified\n  if (options?.backgroundColor) {\n    ctx.fillStyle = options.backgroundColor\n    ctx.fillRect(0, 0, outputWidth, outputHeight)\n  }\n\n  // Apply circular mask if needed\n  if (options?.circle) {\n    ctx.beginPath()\n    ctx.arc(outputWidth / 2, outputHeight / 2, outputWidth / 2, 0, Math.PI * 2)\n    ctx.closePath()\n    ctx.clip()\n  }\n\n  // Calculate source dimensions from points\n  const sourceWidth = points.bottomRightX - points.topLeftX\n  const sourceHeight = points.bottomRightY - points.topLeftY\n\n  // Draw the cropped region\n  ctx.drawImage(\n    image,\n    points.topLeftX,\n    points.topLeftY,\n    sourceWidth,\n    sourceHeight,\n    0,\n    0,\n    outputWidth,\n    outputHeight,\n  )\n\n  return canvas\n}\n\n/**\n * Converts a canvas to a Blob\n */\nexport function canvasToBlob(\n  canvas: HTMLCanvasElement,\n  format: OutputFormat = 'png',\n  quality = 0.92,\n): Promise<Blob> {\n  return new Promise((resolve, reject) => {\n    const mimeType = `image/${format}`\n\n    canvas.toBlob(\n      (blob) => {\n        if (blob) {\n          resolve(blob)\n        } else {\n          reject(new Error('Failed to create blob from canvas'))\n        }\n      },\n      mimeType,\n      quality,\n    )\n  })\n}\n\n/**\n * Converts a canvas to a base64 data URL\n */\nexport function canvasToBase64(\n  canvas: HTMLCanvasElement,\n  format: OutputFormat = 'png',\n  quality = 0.92,\n): string {\n  const mimeType = `image/${format}`\n  return canvas.toDataURL(mimeType, quality)\n}\n",
    "import type { TransformState } from '../types.ts'\n\nexport interface DragCallbacks {\n  onStart?: (state: TransformState) => void\n  onMove?: (state: TransformState) => void\n  onEnd?: (state: TransformState) => void\n}\n\ninterface DragState {\n  isDragging: boolean\n  startX: number\n  startY: number\n  startTransformX: number\n  startTransformY: number\n}\n\n/**\n * Creates drag handlers for an element\n */\nexport function createDragHandler(\n  element: HTMLElement,\n  getTransform: () => TransformState,\n  setTransform: (x: number, y: number) => void,\n  callbacks?: DragCallbacks,\n): () => void {\n  const state: DragState = {\n    isDragging: false,\n    startX: 0,\n    startY: 0,\n    startTransformX: 0,\n    startTransformY: 0,\n  }\n\n  const handlePointerDown = (e: PointerEvent) => {\n    if (e.button !== 0) return // Only left click\n\n    state.isDragging = true\n    state.startX = e.clientX\n    state.startY = e.clientY\n\n    const transform = getTransform()\n    state.startTransformX = transform.x\n    state.startTransformY = transform.y\n\n    element.setPointerCapture(e.pointerId)\n    element.style.cursor = 'grabbing'\n\n    callbacks?.onStart?.(transform)\n  }\n\n  const handlePointerMove = (e: PointerEvent) => {\n    if (!state.isDragging) return\n\n    const deltaX = e.clientX - state.startX\n    const deltaY = e.clientY - state.startY\n\n    const newX = state.startTransformX + deltaX\n    const newY = state.startTransformY + deltaY\n\n    setTransform(newX, newY)\n\n    const transform = getTransform()\n    callbacks?.onMove?.(transform)\n  }\n\n  const handlePointerUp = (e: PointerEvent) => {\n    if (!state.isDragging) return\n\n    state.isDragging = false\n    element.releasePointerCapture(e.pointerId)\n    element.style.cursor = 'grab'\n\n    const transform = getTransform()\n    callbacks?.onEnd?.(transform)\n  }\n\n  // Attach listeners\n  element.addEventListener('pointerdown', handlePointerDown)\n  element.addEventListener('pointermove', handlePointerMove)\n  element.addEventListener('pointerup', handlePointerUp)\n  element.addEventListener('pointercancel', handlePointerUp)\n\n  element.style.cursor = 'grab'\n  element.style.touchAction = 'none' // Prevent browser handling\n\n  // Return cleanup function\n  return () => {\n    element.removeEventListener('pointerdown', handlePointerDown)\n    element.removeEventListener('pointermove', handlePointerMove)\n    element.removeEventListener('pointerup', handlePointerUp)\n    element.removeEventListener('pointercancel', handlePointerUp)\n  }\n}\n",
    "/**\n * Clamps a value between a minimum and maximum\n */\nexport function clamp(value: number, min: number, max: number): number {\n  return Math.min(Math.max(value, min), max)\n}\n",
    "import { clamp } from '../utils/clamp.ts'\n\nexport interface ZoomCallbacks {\n  onChange?: (zoom: number, previousZoom: number) => void\n}\n\nexport interface ZoomConfig {\n  min: number\n  max: number\n}\n\n/**\n * Creates mouse wheel zoom handler\n */\nexport function createWheelZoomHandler(\n  element: HTMLElement,\n  getZoom: () => number,\n  setZoom: (zoom: number) => void,\n  config: ZoomConfig,\n  callbacks?: ZoomCallbacks,\n  requireCtrl = false,\n): () => void {\n  const handleWheel = (e: WheelEvent) => {\n    // Check for ctrl requirement\n    if (requireCtrl && !e.ctrlKey) return\n\n    e.preventDefault()\n\n    const previousZoom = getZoom()\n    const delta = e.deltaY > 0 ? -0.1 : 0.1\n    const newZoom = clamp(previousZoom + delta, config.min, config.max)\n\n    if (newZoom !== previousZoom) {\n      setZoom(newZoom)\n      callbacks?.onChange?.(newZoom, previousZoom)\n    }\n  }\n\n  element.addEventListener('wheel', handleWheel, { passive: false })\n\n  return () => {\n    element.removeEventListener('wheel', handleWheel)\n  }\n}\n\n/**\n * Creates pinch-to-zoom handler for touch devices\n */\nexport function createPinchZoomHandler(\n  element: HTMLElement,\n  getZoom: () => number,\n  setZoom: (zoom: number) => void,\n  config: ZoomConfig,\n  callbacks?: ZoomCallbacks,\n): () => void {\n  let initialDistance = 0\n  let initialZoom = 1\n\n  const getDistance = (touches: TouchList): number => {\n    if (touches.length < 2) return 0\n    const touch1 = touches.item(0)\n    const touch2 = touches.item(1)\n    if (!touch1 || !touch2) return 0\n    const dx = touch1.clientX - touch2.clientX\n    const dy = touch1.clientY - touch2.clientY\n    return Math.sqrt(dx * dx + dy * dy)\n  }\n\n  const handleTouchStart = (e: TouchEvent) => {\n    if (e.touches.length === 2) {\n      e.preventDefault()\n      initialDistance = getDistance(e.touches)\n      initialZoom = getZoom()\n    }\n  }\n\n  const handleTouchMove = (e: TouchEvent) => {\n    if (e.touches.length === 2 && initialDistance > 0) {\n      e.preventDefault()\n\n      const currentDistance = getDistance(e.touches)\n      const scale = currentDistance / initialDistance\n      const previousZoom = getZoom()\n      const newZoom = clamp(initialZoom * scale, config.min, config.max)\n\n      if (newZoom !== previousZoom) {\n        setZoom(newZoom)\n        callbacks?.onChange?.(newZoom, previousZoom)\n      }\n    }\n  }\n\n  const handleTouchEnd = () => {\n    initialDistance = 0\n  }\n\n  element.addEventListener('touchstart', handleTouchStart, { passive: false })\n  element.addEventListener('touchmove', handleTouchMove, { passive: false })\n  element.addEventListener('touchend', handleTouchEnd)\n\n  return () => {\n    element.removeEventListener('touchstart', handleTouchStart)\n    element.removeEventListener('touchmove', handleTouchMove)\n    element.removeEventListener('touchend', handleTouchEnd)\n  }\n}\n",
    "/**\n * Loads an image from a URL and returns a promise\n */\nexport function loadImage(url: string): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const img = new Image()\n\n    // Only set crossOrigin for actual URLs, not data URLs\n    if (!url.startsWith('data:')) {\n      img.crossOrigin = 'anonymous'\n    }\n\n    img.onload = () => resolve(img)\n    img.onerror = () => reject(new Error(`Failed to load image: ${url}`))\n\n    img.src = url\n  })\n}\n\n/**\n * Converts a File or Blob to a data URL\n */\nexport function fileToDataUrl(file: File | Blob): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader()\n\n    reader.onload = () => {\n      if (typeof reader.result === 'string') {\n        resolve(reader.result)\n      } else {\n        reject(new Error('Failed to read file as data URL'))\n      }\n    }\n\n    reader.onerror = () => reject(new Error('Failed to read file'))\n\n    reader.readAsDataURL(file)\n  })\n}\n\n/**\n * Gets the natural dimensions of an image\n */\nexport function getImageDimensions(img: HTMLImageElement): { width: number; height: number } {\n  return {\n    width: img.naturalWidth,\n    height: img.naturalHeight,\n  }\n}\n\n/**\n * Calculates the aspect ratio of dimensions\n */\nexport function aspectRatio(width: number, height: number): number {\n  return width / height\n}\n\n/**\n * Calculates initial zoom to fit image in boundary\n */\nexport function calculateInitialZoom(\n  imageWidth: number,\n  imageHeight: number,\n  viewportWidth: number,\n  viewportHeight: number,\n): number {\n  const widthRatio = viewportWidth / imageWidth\n  const heightRatio = viewportHeight / imageHeight\n\n  // Use the larger ratio to ensure viewport is filled\n  return Math.max(widthRatio, heightRatio)\n}\n",
    "import type { CropPoints, PointsArray } from '../types'\n\n// Re-export for convenience\nexport type { PointsArray }\n\n/**\n * Input type that accepts either format\n */\nexport type PointsInput = CropPoints | PointsArray\n\n/**\n * Normalizes points input to object format\n */\nexport function normalizePoints(points: PointsInput | undefined): CropPoints | undefined {\n  if (points === undefined) {\n    return undefined\n  }\n\n  if (Array.isArray(points)) {\n    if (points.length !== 4) {\n      throw new Error(\n        'PointsArray must have exactly 4 elements: [topLeftX, topLeftY, bottomRightX, bottomRightY]',\n      )\n    }\n    return {\n      topLeftX: points[0],\n      topLeftY: points[1],\n      bottomRightX: points[2],\n      bottomRightY: points[3],\n    }\n  }\n\n  return points\n}\n\n/**\n * Converts object points to array format (for v2.6 compatibility if needed)\n */\nexport function pointsToArray(points: CropPoints): PointsArray {\n  return [points.topLeftX, points.topLeftY, points.bottomRightX, points.bottomRightY]\n}\n",
    "import type {\n  BindOptions,\n  Boundary,\n  CropPoints,\n  CroppieData,\n  CroppieEventHandler,\n  CroppieEvents,\n  CroppieOptions,\n  ResultOptions,\n  TransformState,\n  Viewport,\n  ZoomConfig,\n} from './types.ts'\n\nimport {\n  createBoundary,\n  createContainer,\n  createOverlay,\n  createPreview,\n  createSliderContainer,\n  createViewport,\n  createZoomSlider,\n} from './ui/index.ts'\n\nimport { canvasToBase64, canvasToBlob, drawCroppedImage } from './canvas/index.ts'\nimport { createDragHandler } from './input/drag.ts'\nimport { createPinchZoomHandler, createWheelZoomHandler } from './input/zoom.ts'\nimport {\n  calculateInitialZoom,\n  clamp,\n  fileToDataUrl,\n  loadImage,\n  normalizePoints,\n  setTransform,\n} from './utils/index.ts'\n\nconst DEFAULT_ZOOM: ZoomConfig = {\n  min: 0.1,\n  max: 10,\n}\n\n/**\n * Modern, TypeScript-first image cropper.\n *\n * @example\n * ```ts\n * const croppie = new Croppie(element, {\n *   viewport: { width: 200, height: 200, type: 'circle' }\n * })\n *\n * await croppie.bind({ url: 'image.jpg' })\n * const blob = await croppie.result({ type: 'blob' })\n * ```\n */\nexport class Croppie {\n  private readonly element: HTMLElement\n  private readonly options: Required<\n    Pick<CroppieOptions, 'viewport' | 'boundary' | 'showZoomer' | 'mouseWheelZoom'>\n  > &\n    CroppieOptions\n\n  // DOM elements\n  private container: HTMLDivElement | null = null\n  private boundaryEl: HTMLDivElement | null = null\n  private viewportEl: HTMLDivElement | null = null\n  private overlayEl: HTMLDivElement | null = null\n  private previewEl: HTMLImageElement | null = null\n  private sliderEl: HTMLInputElement | null = null\n\n  // State\n  private image: HTMLImageElement | null = null\n  private transform: TransformState = { x: 0, y: 0, scale: 1 }\n  private zoomConfig: ZoomConfig\n\n  // Event handlers\n  private eventHandlers: Map<keyof CroppieEvents, Set<CroppieEventHandler<keyof CroppieEvents>>> =\n    new Map()\n\n  // Cleanup functions\n  private cleanupFns: Array<() => void> = []\n\n  constructor(element: HTMLElement, options: CroppieOptions) {\n    this.element = element\n\n    // Calculate default boundary (viewport + 100px padding)\n    const defaultBoundary: Boundary = {\n      width: options.viewport.width + 100,\n      height: options.viewport.height + 100,\n    }\n\n    this.options = {\n      ...options,\n      boundary: options.boundary ?? defaultBoundary,\n      showZoomer: options.showZoomer ?? true,\n      mouseWheelZoom: options.mouseWheelZoom ?? true,\n    }\n\n    this.zoomConfig = {\n      ...DEFAULT_ZOOM,\n      ...options.zoom,\n    }\n\n    // Deprecation warning for v2.6 migration\n    if (options.enableOrientation !== undefined) {\n      console.warn(\n        '[@bayinformatics/croppie] enableOrientation is deprecated and has no effect. Rotation support is planned for a future release.',\n      )\n    }\n\n    this.createElements()\n    this.attachEventHandlers()\n  }\n\n  /**\n   * Creates all DOM elements\n   */\n  private createElements(): void {\n    this.container = createContainer(this.options.customClass)\n    this.boundaryEl = createBoundary(this.options.boundary)\n    this.viewportEl = createViewport(this.options.viewport)\n    this.overlayEl = createOverlay(this.options.boundary, this.options.viewport)\n    this.previewEl = createPreview()\n\n    // Assemble the DOM tree\n    this.boundaryEl.appendChild(this.previewEl)\n    this.boundaryEl.appendChild(this.overlayEl)\n    this.boundaryEl.appendChild(this.viewportEl)\n    this.container.appendChild(this.boundaryEl)\n\n    // Add zoom slider if enabled\n    if (this.options.showZoomer) {\n      const sliderWrap = createSliderContainer()\n      this.sliderEl = createZoomSlider(\n        this.zoomConfig.min,\n        this.zoomConfig.max,\n        this.transform.scale,\n      )\n      sliderWrap.appendChild(this.sliderEl)\n      this.container.appendChild(sliderWrap)\n\n      // Slider input handler\n      const handleSliderInput = () => {\n        if (this.sliderEl) {\n          const previousZoom = this.transform.scale\n          this.setZoom(Number.parseFloat(this.sliderEl.value))\n          this.emitEvent('zoom', { zoom: this.transform.scale, previousZoom })\n        }\n      }\n      this.sliderEl.addEventListener('input', handleSliderInput)\n      this.cleanupFns.push(() => {\n        this.sliderEl?.removeEventListener('input', handleSliderInput)\n      })\n    }\n\n    this.element.appendChild(this.container)\n  }\n\n  /**\n   * Attaches drag and zoom event handlers\n   */\n  private attachEventHandlers(): void {\n    if (!this.boundaryEl || !this.previewEl) return\n\n    // Drag handler\n    const dragCleanup = createDragHandler(\n      this.boundaryEl,\n      () => this.transform,\n      (x, y) => {\n        this.transform.x = x\n        this.transform.y = y\n        this.updateTransform()\n        this.emitUpdate()\n      },\n    )\n    this.cleanupFns.push(dragCleanup)\n\n    // Wheel zoom handler\n    if (this.options.mouseWheelZoom) {\n      const requireCtrl = this.options.mouseWheelZoom === 'ctrl'\n      const wheelCleanup = createWheelZoomHandler(\n        this.boundaryEl,\n        () => this.transform.scale,\n        (zoom) => this.setZoom(zoom),\n        this.zoomConfig,\n        {\n          onChange: (zoom, previousZoom) => {\n            this.emitEvent('zoom', { zoom, previousZoom })\n          },\n        },\n        requireCtrl,\n      )\n      this.cleanupFns.push(wheelCleanup)\n    }\n\n    // Pinch zoom handler\n    const pinchCleanup = createPinchZoomHandler(\n      this.boundaryEl,\n      () => this.transform.scale,\n      (zoom) => this.setZoom(zoom),\n      this.zoomConfig,\n      {\n        onChange: (zoom, previousZoom) => {\n          this.emitEvent('zoom', { zoom, previousZoom })\n        },\n      },\n    )\n    this.cleanupFns.push(pinchCleanup)\n  }\n\n  /**\n   * Loads an image into the cropper\n   */\n  async bind(options: BindOptions | string): Promise<void> {\n    const bindOptions: BindOptions = typeof options === 'string' ? { url: options } : options\n\n    this.image = await loadImage(bindOptions.url)\n\n    if (this.previewEl) {\n      this.previewEl.src = bindOptions.url\n    }\n\n    // Calculate initial zoom to fit viewport\n    const initialZoom =\n      bindOptions.zoom ??\n      calculateInitialZoom(\n        this.image.naturalWidth,\n        this.image.naturalHeight,\n        this.options.viewport.width,\n        this.options.viewport.height,\n      )\n\n    this.transform = {\n      x: 0,\n      y: 0,\n      scale: clamp(initialZoom, this.zoomConfig.min, this.zoomConfig.max),\n    }\n\n    // Apply initial points if provided\n    if (bindOptions.points) {\n      const normalizedPoints = normalizePoints(bindOptions.points)\n      if (normalizedPoints) {\n        // TODO: Calculate transform from points - not yet implemented\n        console.warn(\n          '[@bayinformatics/croppie] Initial points are not yet fully supported. Provided:',\n          normalizedPoints,\n        )\n      }\n    }\n\n    this.updateTransform()\n    this.updateSlider()\n  }\n\n  /**\n   * Binds a File or Blob to the cropper\n   */\n  async bindFile(file: File | Blob): Promise<void> {\n    const dataUrl = await fileToDataUrl(file)\n    await this.bind({ url: dataUrl })\n  }\n\n  /**\n   * Gets the current cropped result\n   */\n  async result(options: ResultOptions): Promise<Blob | string | HTMLCanvasElement> {\n    if (!this.image) {\n      throw new Error('No image bound')\n    }\n\n    const points = this.getPoints()\n    const viewport = this.options.viewport\n\n    // Determine output size\n    let outputWidth: number\n    let outputHeight: number\n\n    if (options.size === 'viewport') {\n      outputWidth = viewport.width\n      outputHeight = viewport.height\n    } else if (options.size === 'original') {\n      outputWidth = points.bottomRightX - points.topLeftX\n      outputHeight = points.bottomRightY - points.topLeftY\n    } else if (options.size) {\n      outputWidth = options.size.width\n      outputHeight = options.size.height\n    } else {\n      outputWidth = viewport.width\n      outputHeight = viewport.height\n    }\n\n    const canvas = drawCroppedImage(this.image, points, outputWidth, outputHeight, {\n      circle: options.circle ?? viewport.type === 'circle',\n      backgroundColor: options.backgroundColor,\n    })\n\n    switch (options.type) {\n      case 'canvas':\n        return canvas\n      case 'base64':\n        return canvasToBase64(canvas, options.format, options.quality)\n      case 'blob':\n        return canvasToBlob(canvas, options.format, options.quality)\n      default:\n        throw new Error(`Unknown result type: ${options.type}`)\n    }\n  }\n\n  /**\n   * Gets the current crop data\n   */\n  get(): CroppieData {\n    return {\n      points: this.getPoints(),\n      zoom: this.transform.scale,\n    }\n  }\n\n  /**\n   * Gets the current zoom level\n   */\n  get zoom(): number {\n    return this.transform.scale\n  }\n\n  /**\n   * Sets the zoom level\n   */\n  set zoom(value: number) {\n    this.setZoom(value)\n  }\n\n  /**\n   * Sets the zoom level with clamping\n   */\n  setZoom(value: number): void {\n    const previousZoom = this.transform.scale\n    this.transform.scale = clamp(value, this.zoomConfig.min, this.zoomConfig.max)\n    this.updateTransform()\n    this.updateSlider()\n\n    if (previousZoom !== this.transform.scale) {\n      this.emitUpdate()\n    }\n  }\n\n  /**\n   * Rotates the image by 90 degree increments\n   */\n  rotate(degrees: 90 | 180 | 270 | -90): void {\n    // TODO: Implement rotation\n    console.warn('Rotation not yet implemented:', degrees)\n  }\n\n  /**\n   * Resets the cropper to initial state\n   */\n  reset(): void {\n    if (this.image) {\n      const initialZoom = calculateInitialZoom(\n        this.image.naturalWidth,\n        this.image.naturalHeight,\n        this.options.viewport.width,\n        this.options.viewport.height,\n      )\n\n      this.transform = { x: 0, y: 0, scale: initialZoom }\n      this.updateTransform()\n      this.updateSlider()\n      this.emitUpdate()\n    }\n  }\n\n  /**\n   * Destroys the cropper and cleans up\n   */\n  destroy(): void {\n    // Run all cleanup functions\n    for (const cleanup of this.cleanupFns) {\n      cleanup()\n    }\n    this.cleanupFns = []\n\n    // Clear event handlers\n    this.eventHandlers.clear()\n\n    // Remove DOM elements\n    if (this.container?.parentNode) {\n      this.container.parentNode.removeChild(this.container)\n    }\n\n    this.container = null\n    this.boundaryEl = null\n    this.viewportEl = null\n    this.overlayEl = null\n    this.previewEl = null\n    this.sliderEl = null\n    this.image = null\n  }\n\n  /**\n   * Registers an event handler\n   */\n  on<K extends keyof CroppieEvents>(event: K, handler: CroppieEventHandler<K>): void {\n    if (!this.eventHandlers.has(event)) {\n      this.eventHandlers.set(event, new Set())\n    }\n    this.eventHandlers.get(event)?.add(handler as CroppieEventHandler<keyof CroppieEvents>)\n  }\n\n  /**\n   * Removes an event handler\n   */\n  off<K extends keyof CroppieEvents>(event: K, handler: CroppieEventHandler<K>): void {\n    this.eventHandlers.get(event)?.delete(handler as CroppieEventHandler<keyof CroppieEvents>)\n  }\n\n  /**\n   * Updates the CSS transform on the preview element\n   */\n  private updateTransform(): void {\n    if (this.previewEl) {\n      // Center the image in the boundary\n      const boundaryWidth = this.options.boundary.width\n      const boundaryHeight = this.options.boundary.height\n      const imageWidth = this.image?.naturalWidth ?? 0\n      const imageHeight = this.image?.naturalHeight ?? 0\n\n      const scaledWidth = imageWidth * this.transform.scale\n      const scaledHeight = imageHeight * this.transform.scale\n\n      const centerX = (boundaryWidth - scaledWidth) / 2 + this.transform.x\n      const centerY = (boundaryHeight - scaledHeight) / 2 + this.transform.y\n\n      setTransform(this.previewEl, centerX, centerY, this.transform.scale)\n    }\n  }\n\n  /**\n   * Updates the slider value to match current zoom\n   */\n  private updateSlider(): void {\n    if (this.sliderEl) {\n      this.sliderEl.value = String(this.transform.scale)\n    }\n  }\n\n  /**\n   * Calculates the crop points based on current transform\n   */\n  private getPoints(): CropPoints {\n    if (!this.image) {\n      return { topLeftX: 0, topLeftY: 0, bottomRightX: 0, bottomRightY: 0 }\n    }\n\n    const viewport = this.options.viewport\n    const boundary = this.options.boundary\n    const imageWidth = this.image.naturalWidth\n    const imageHeight = this.image.naturalHeight\n\n    // Calculate the visible area in image coordinates\n    const scaledWidth = imageWidth * this.transform.scale\n    const scaledHeight = imageHeight * this.transform.scale\n\n    const imageLeft = (boundary.width - scaledWidth) / 2 + this.transform.x\n    const imageTop = (boundary.height - scaledHeight) / 2 + this.transform.y\n\n    const viewportLeft = (boundary.width - viewport.width) / 2\n    const viewportTop = (boundary.height - viewport.height) / 2\n\n    // Convert viewport coordinates to image coordinates\n    const topLeftX = (viewportLeft - imageLeft) / this.transform.scale\n    const topLeftY = (viewportTop - imageTop) / this.transform.scale\n    const bottomRightX = topLeftX + viewport.width / this.transform.scale\n    const bottomRightY = topLeftY + viewport.height / this.transform.scale\n\n    return {\n      topLeftX: Math.max(0, topLeftX),\n      topLeftY: Math.max(0, topLeftY),\n      bottomRightX: Math.min(imageWidth, bottomRightX),\n      bottomRightY: Math.min(imageHeight, bottomRightY),\n    }\n  }\n\n  /**\n   * Emits an update event\n   */\n  private emitUpdate(): void {\n    this.emitEvent('update', this.get())\n  }\n\n  /**\n   * Emits an event to all registered handlers\n   */\n  private emitEvent<K extends keyof CroppieEvents>(event: K, data: CroppieEvents[K]): void {\n    const handlers = this.eventHandlers.get(event)\n    if (handlers) {\n      for (const handler of handlers) {\n        ;(handler as CroppieEventHandler<K>)(data)\n      }\n    }\n  }\n}\n"
  ],
  "mappings": "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",
  "debugId": "CD80045C35FDAA7164756E2164756E21",
  "names": []
}